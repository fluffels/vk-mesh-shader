#version 450
 
#extension GL_NV_mesh_shader : require
 
layout(local_size_x=1) in;
layout(triangles, max_vertices=4, max_primitives=2) out;

struct Vertex {
  vec3 position;
};

layout(binding=1) readonly buffer Vertices {
  Vertex vertices[];
};
 
// Custom vertex output block
layout (location=0) out PerVertexData
{
  vec2 uv;
} v_out[];  // [max_vertices]

#include "uniforms.glsl"
#include "quaternion.glsl"
 
const vec3 colors[4] = {
  vec3(1.0,0.0,0.0),
  vec3(0.0,1.0,0.0),
  vec3(0.0,0.0,1.0),
  vec3(1.0,1.0,1.0),
};
 
void main()
{
  const uint i = gl_WorkGroupID.x;
  vec3 p = vertices[i].position;
  const float d = .1f;

  vec4 p0 = vec4(p.x, 0, p.z, 1);

  p0 -= uniforms.eye;
  p0 = rotate_vertex_position(uniforms.rotation, p0);

  vec4 p1 = vec4(p0.x      , p0.y - 1, p0.z, 1);
  vec4 p2 = vec4(p0.x + 1.f,     p0.y, p0.z, 1);
  vec4 p3 = vec4(p0.x + 1.f, p0.y - 1, p0.z, 1);

  // Vertices position
  gl_MeshVerticesNV[0].gl_Position = uniforms.proj * p0; 
  gl_MeshVerticesNV[1].gl_Position = uniforms.proj * p1; 
  gl_MeshVerticesNV[2].gl_Position = uniforms.proj * p2; 
  gl_MeshVerticesNV[3].gl_Position = uniforms.proj * p3; 
 
  // Vertices color
  v_out[0].uv = vec2(0.f, 0.25f);
  v_out[1].uv = vec2(0.f, 0.f);
  v_out[2].uv = vec2(0.25f, 0.25f);
  v_out[3].uv = vec2(0.25f, 0.f);
 
  // Triangle indices
  gl_PrimitiveIndicesNV[0] = 0;
  gl_PrimitiveIndicesNV[1] = 1;
  gl_PrimitiveIndicesNV[2] = 2;
  gl_PrimitiveIndicesNV[3] = 2;
  gl_PrimitiveIndicesNV[4] = 1;
  gl_PrimitiveIndicesNV[5] = 3;
 
  // Number of triangles  
  gl_PrimitiveCountNV = 2;
}
